package com.engine.service

import com.engine.model.*
import com.engine.orchestrator.InvestmentOrchestrator
import com.engine.orchestrator.TickInterval
import org.springframework.stereotype.Service
import java.time.LocalDate

@Service
class ModelChainOrchestrator(
    private val intelligenceService: IntelligenceService,
    private val marketDataService: MarketDataService,
    private val simulationEngine: SimulationEngine,
    private val yamlParser: YamlParserService
) : InvestmentOrchestrator { // Implementing the interface

    override fun runWeeklyAudit(date: LocalDate): AuditResult {
        println("--- Starting Weekly Audit for $date ---")

        // 1. DATA INGESTION: Load the raw static definition
        // We reload this every time to ensure 'statelessness' (Amnesia bit)
        val rawPortfolio = yamlParser.parsePortfolio("src/main/resources/assets.yaml")
        val orchestrationConfig = yamlParser.parseOrchestration("src/main/resources/orchestration.yaml")

        // 2. MARKET SYNC: Calculate real-time Net Worth
        // (Crucial so the AI knows if '10 NVDA' is worth $1k or $10k)
        val currentPrices = fetchAssetPrices(rawPortfolio, date)
        val totalNetWorth = calculateNetWorth(rawPortfolio, currentPrices)

        // We create a "Rich Context" string so the AI sees the actual $ values, not just share counts
        val portfolioContext = generateContextWithValues(rawPortfolio, currentPrices, totalNetWorth)

        // 3. PHASE 1: MACRO CONSENSUS
        println("... Fetching Macro Consensus")
        val macro = intelligenceService.getMacroConsensus(date, orchestrationConfig.phases["macro"])

        // 4. PHASE 2: THE INTELLIGENCE CHAIN
        // We pass the 'portfolioContext' string to the Auditor so it sees prices
        // Note: You might need to adjust AuditorService to accept this enriched string or relying on the toString()
        // For now, we assume the IntelligenceService handles the flow defined in the interface.
        println("... Running Audit Chain (Auditor -> Anti-Thesis -> Chairman)")
        val recommendations = intelligenceService.runAuditChain(
            rawPortfolio, // The object
            macro,
            date,
            orchestrationConfig
        )

        // 5. PHASE 3: CHAIRMAN'S DECISION & SIMULATION
        // The Chairman has spoken. Now we package the result.
        // In a real simulation, we would apply these moves to a "Digital Twin".

        // Construct the final report
        // Note: In your current flow, 'runAuditChain' returns List<Recommendation>.
        // Ideally, it should return the full 'StrategyReport' or we access it from the Chairman.
        // Assuming we reconstruct the StrategyReport or modify the service to return it.
        // For this implementation, we'll wrap the recommendations.

        val strategyReport = StrategyReport(
            mainThesis = "Generated by AI Chain",
            antiThesisSummary = "Consolidated Critique",
            finalRecommendations = recommendations,
            riskAssessment = RiskLevel.MEDIUM,
            executiveDilemma = "Automated execution pending user review"
        )

        val insights = simulationEngine.generateInsights(rawPortfolio)

        return AuditResult(
            auditDate = date,
            totalNetWorthBaseCurrency = totalNetWorth,
            strategy = strategyReport,
            insights = insights
        )
    }

    override fun runHistoricalSimulation(
        initialState: GlobalPortfolio,
        startDate: LocalDate,
        months: Long,
        tickInterval: TickInterval?
    ): SimulationSummary {
        TODO("Not yet implemented")
    }

    // --- Helper Methods to Enriched Data for the AI ---

    private fun fetchAssetPrices(portfolio: GlobalPortfolio, date: LocalDate): Map<String, java.math.BigDecimal> {
        val prices = mutableMapOf<String, java.math.BigDecimal>()
        portfolio.privatePortfolio?.forEach { asset ->
            // If date is null, MarketDataService fetches Real-Time
            prices[asset.ticker] = marketDataService.getPrice(asset.ticker, date)
        }
        return prices
    }

    private fun calculateNetWorth(portfolio: GlobalPortfolio, prices: Map<String, java.math.BigDecimal>): java.math.BigDecimal {
        var total = java.math.BigDecimal.ZERO

        // Sum Equity
        portfolio.privatePortfolio?.forEach { asset ->
            val price = prices[asset.ticker] ?: java.math.BigDecimal.ZERO
            total = total.add(price.multiply(asset.shares))
        }

        // Sum Cash
        portfolio.wallets.forEach { cash ->
            // Simplified: assuming base currency for now, or use marketDataService.getExchangeRate()
            total = total.add(cash.amount)
        }

        return total
    }

    private fun generateContextWithValues(portfolio: GlobalPortfolio, prices: Map<String, java.math.BigDecimal>, netWorth: java.math.BigDecimal): String {
        return """
            Portfolio Total Value: $netWorth
            Holdings:
            ${portfolio.privatePortfolio?.joinToString("\n") {
            "${it.ticker}: ${it.shares} shares @ ${prices[it.ticker]} = ${prices[it.ticker]?.multiply(it.shares)}"
        }}
            Cash: ${portfolio.wallets}
        """.trimIndent()
    }
}
